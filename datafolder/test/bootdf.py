# -*- coding: utf-8 -*-
# flake8: noqa
# pylint: skip-file
# File generated by the 'datafolder' package

# datafolder - easy install and access to data files

# The MIT License (MIT)

# Copyright (c) 2015 Alexandre Lima Conde

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

###         PUT THIS FILE INSIDE YOUR PROJECT

import fnmatch
import os
import sys

from stat import S_IRUSR, S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, S_IWOTH

MODE666 = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH


__version__ = '0.2.2'


def in_virtual():
    return True if hasattr(sys, 'real_prefix') else False


class DataFolderException(Exception):
    """Base exception for 'datafolder' package.

    Should't NOT be raised directly, but can be used as a
    catch-all exception for the package.

    """
    pass

class DataFolderNotMadeError(DataFolderException):
    pass

class PythonNotSupportedError(DataFolderException):
    pass

class DataFolderNotFoundError(DataFolderException):
    pass


class Installer(object):
    def __init__(self, sysargv):
        self.ARGVS = sysargv
        self.FIRSTRUN = 'egg_info' in self.ARGVS
        self.PIP = '-c' in self.ARGVS
        self.INSTALL = any((m in self.ARGVS for m in ('install', 'develop')))\
            or self.PIP
        self.WINDOWS = os.name == 'nt'
        self.VIRTUAL = in_virtual()
        self.SECONDRUN = self.INSTALL and not self.FIRSTRUN
        self.CONFDIR = ''
        self.DATAPATH = ''
        self.PYSUPPORT = ()

    @staticmethod
    def _uxchown(fp):
        from pwd import getpwnam, getpwuid
        from grp import getgrnam, getgrgid
        uid = getpwnam(os.getenv("SUDO_USER",
                                 getpwuid(os.getuid()).pw_name)).pw_uid
        gid = getgrnam(os.getenv("SUDO_USER",
                                 getgrgid(os.getgid()).gr_name)).gr_gid
        os.chown(fp, uid, gid)

    def env(self):
        return {'FIRSTRUN': self.FIRSTRUN,
                'SECONDRUN': self.SECONDRUN,
                'INSTALL': self.INSTALL,
                'WINDOWS': self.WINDOWS,
                'VIRTUAL': self.VIRTUAL,
                'PYSUPPORT': self.PYSUPPORT,
                'DATAPATH': self.DATAPATH}

    def data_path(self, datadir):
        datadir = datadir.strip('. ')
        self.CONFDIR = '.' + datadir if not self.WINDOWS else datadir
        if self.VIRTUAL:
            virtualpath = sys.prefix
            installpath = os.path.join(virtualpath, datadir)
        else:
            user = '~%s' % os.getenv("SUDO_USER", '')
            homepath = os.path.expanduser(user)\
                if not self.WINDOWS else os.getenv('APPDATA')
            installpath = os.path.join(homepath, self.CONFDIR)
        if not os.path.isdir(installpath) and self.INSTALL:
            try:
                print('making data folder %s' % installpath)
                os.mkdir(installpath)
                if not self.WINDOWS:
                    self._uxchown(installpath)
            except:
                msg = 'Abort: data folder NOT made with path %s!' % installpath
                raise DataFolderNotMadeError(msg)
        self.DATAPATH = installpath
        return self.DATAPATH

    def pos_setup(self, datafiles):
        if not self.WINDOWS and self.SECONDRUN:
            for dat in datafiles:
                datp = os.path.join(self.DATAPATH, dat)
                if not os.path.isfile(datp):
                    print("Warning: file %s doesn't exist!" % datp)
                    continue
                try:
                    self._uxchown(datp)
                    print('changing mode of %s to 666' % dat)
                except:
                    print('Warning: permissions not set for file %s' % dat)

    def support(self, pys=None):
        if not pys:
            return True
        self.PYSUPPORT = pys
        py = sys.version[:3]
        if py not in self.PYSUPPORT:
            raise PythonNotSupportedError('Python %s is not supported!' % py)
        return True


class DataFolder(object):

    """Discover data folder and access to his files."""

    def __init__(self, foldername=None):
        """Set the basic class attributes."""
        if not foldername:
            # try the name of the current folder (~ package)
            foldername = os.path.basename(os.path.abspath(__file__))
            if not foldername:
                raise DataFolderNotFoundError('Supply the name of the data folder')
        self.folderpath = self._find_location(foldername)
        if not self.folderpath:
            raise DataFolderNotFoundError('Supply the name of the data folder')
        # NOTE: sub-folders are NOT supported!
        self.filenames = os.listdir(self.folderpath)
        self.files = dict(((fn, os.path.join(self.folderpath, fn))
                           for fn in self.filenames))
        self.filepaths = list(self.files.values())

    @staticmethod
    def _find_location(foldername):
        """Find the location of the data folder."""
        raw_foldername = foldername
        foldername = foldername.strip('.')
        if in_virtual():
            data_dir = os.path.join(sys.prefix, foldername)
        else:
            if os.name == 'nt':
                data_dir = os.path.join(os.getenv('APPDATA'), foldername)
            else:
                data_dir = os.path.expanduser('~/.%s' % foldername)
        if not os.path.isdir(data_dir):
            raise DataFolderNotFoundError("Data folder '{}' wasn't found!"
                                          .format(raw_foldername))
        return data_dir

    def writable(self, fn):
        """Verify if a file in the data folder is writable."""
        return os.access(self.files[fn], os.W_OK)

    def exists(self, path):
        """Check if the path is a file or a directory in the data folder."""
        return os.path.exists(self.files[path])

    def isfile(self, fn):
        """Check if a file exists in the data folder."""
        return os.path.isfile(self.files[fn])

    def splitbasename(self, fn):
        """Split the basename (of a file) in name and extension."""
        return os.path.splitext(fn)

    def uxchmod(self, fn, mode=MODE666):
        """Change the mode of the file (default is 0666)."""
        return os.chmod(self.files[fn], mode)

    def select(self, pattern='*'):
        """List of data files that match a given pattern."""
        return fnmatch.filter(self.filenames, pattern)
